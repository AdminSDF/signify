
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function requestingUserRole() {
      // Allow read for any signed-in user to prevent cascading failures
      // This call is protected by the /users/{userId} read rule itself
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }
    
    function isSuperAdmin() {
      return requestingUserRole() == 'super-admin';
    }
    
    function isAdmin() {
      return requestingUserRole() in ['admin', 'super-admin'];
    }

    function isFinanceStaff() {
      return requestingUserRole() in ['finance-staff', 'admin', 'super-admin'];
    }
    
    function isSupportStaff() {
      return requestingUserRole() in ['support-staff', 'admin', 'super-admin'];
    }

    // Collection: users
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      allow create: if isOwner(userId);

      function isUpdatingOwnAllowedFields() {
        let allowedPublicKeys = ['displayName', 'photoURL', 'lastActive', 'isOnline', 'currentGame', 'upiIdForWithdrawal', 'bankDetailsForWithdrawal', 'toursCompleted', 'tags'];
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        
        // Disallow direct modification of critical fields by anyone except admins
        let forbiddenKeys = ['uid', 'email', 'createdAt', 'role', 'isAdmin', 'isBlocked', 'referralCode', 'referredBy', 'referrals', 'referralEarnings', 'referralMilestones', 'totalWinnings', 'totalSpinsPlayed', 'totalWins', 'totalDeposited', 'totalWithdrawn', 'vipUntil'];
        if (changedKeys.hasAny(forbiddenKeys)) {
            return false;
        }
        
        // If balances are being changed, it must only be a debit
        if (changedKeys.has('balances')) {
            let balanceKeys = request.resource.data.balances.keys();
            let allDebits = balanceKeys.forall(tier =>
                !(tier in resource.data.balances) || // If it's a new tier, it's not a debit (this is ok)
                request.resource.data.balances[tier] <= resource.data.balances[tier] // If tier exists, new value must be less than or equal to old
            );
            if (!allDebits) {
                return false; // A credit was attempted, which is not allowed
            }
        }
        
        // Allow the update if no forbidden keys were touched, and if balances were changed, they were only debits.
        return true;
      }

      // UPDATE:
      // 1. Admins can update anything.
      // 2. The user can update their own document, but with restrictions.
      allow update: if isAdmin() || (isOwner(userId) && isUpdatingOwnAllowedFields());
    }

    // Collection: transactions
    match /transactions/{transactionId} {
      allow get: if isSignedIn() && (resource.data.userId == request.auth.uid || isFinanceStaff());
      allow list: if isSignedIn() && (isFinanceStaff() || (request.query.where.field == 'userId' && request.query.where.value == request.auth.uid));
      allow create, update, delete: if false; // Server only
    }
    
    // Collection: withdrawalRequests
    match /withdrawalRequests/{requestId} {
      allow get: if isSignedIn() && (resource.data.userId == request.auth.uid || isFinanceStaff());
      allow list: if isSignedIn() && (isFinanceStaff() || (request.query.where.field == 'userId' && request.query.where.value == request.auth.uid));
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isFinanceStaff();
      allow delete: if false;
    }

    // Collection: addFundRequests
    match /addFundRequests/{requestId} {
      allow get: if isSignedIn() && (resource.data.userId == request.auth.uid || isFinanceStaff());
      allow list: if isSignedIn() && (isFinanceStaff() || (request.query.where.field == 'userId' && request.query.where.value == request.auth.uid));
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isFinanceStaff();
      allow delete: if false;
    }

    // Collection: appConfiguration
    match /appConfiguration/{docId} {
      allow get: if isSignedIn();
      allow write: if isSuperAdmin();
    }

    // Collection: supportTickets
    match /supportTickets/{ticketId} {
      allow get: if isSignedIn() && (resource.data.userId == request.auth.uid || isSupportStaff());
      allow list: if isSignedIn() && (isSupportStaff() || (request.query.where.field == 'userId' && request.query.where.value == request.auth.uid));
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && (resource.data.userId == request.auth.uid || isSupportStaff());
    }
    
    // Notifications Subcollection
    match /users/{userId}/notifications/{notificationId} {
      allow read, write: if isOwner(userId);
      allow list: if isOwner(userId);
    }

    // Collections for server-side logic only
    match /activityLogs/{logId} { allow read, write: if false; }
    match /fraudAlerts/{alertId} { allow read, write: if false; }
    match /systemStats/{statId} { allow read: if isFinanceStaff(); allow write: if false; }
    match /userRewards/{userId} { allow get: if isOwner(userId); allow write: if false; }

    // Collection: tournaments
    match /tournaments/{tournamentId} {
      allow get, list: if isSignedIn();
      allow create, delete: if isAdmin();
      
      function isAddingSelfToParticipants() {
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        if (changedKeys.size() != 1 || !changedKeys.has('participants')) {
          return false;
        }
        let addedIds = request.resource.data.participants.removeAll(resource.data.participants);
        return addedIds.size() == 1 && addedIds[0] == request.auth.uid;
      }

      allow update: if isAdmin() || isAddingSelfToParticipants();
      
      match /participants/{userId} {
        allow get, list: if isSignedIn();
        allow create: if isOwner(userId);
        allow update, delete: if false; // Server only, e.g. updating score
      }
    }
  }
}
