
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserData(userId) {
        return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function hasRole(allowedRoles) {
      let userRole = getUserData(request.auth.uid).role;
      return isSignedIn() && userRole in allowedRoles;
    }

    function isSuperAdmin() { return hasRole(['super-admin']); }
    function isAdminOrHigher() { return hasRole(['super-admin', 'admin']); }
    function isFinanceStaffOrHigher() { return hasRole(['super-admin', 'admin', 'finance-staff']); }
    function isSupportStaffOrHigher() { return hasRole(['super-admin', 'admin', 'support-staff']); }
    
    // --- Collection Rules ---

    match /users/{userId} {
      allow read: if isSignedIn() && (isOwner(userId) || isAdminOrHigher());
      allow create: if isOwner(userId);
      allow update: if (isOwner(userId) && isUpdatingOwnSafeFields()) || isAdminOrHigher();
      allow delete: if isSuperAdmin();

      function isUpdatingOwnSafeFields() {
        let incoming = request.resource.data;
        let existing = resource.data;
        
        let mutableFields = ['displayName', 'photoURL', 'isOnline', 'lastActive', 'currentGame', 'upiIdForWithdrawal', 'bankDetailsForWithdrawal', 'toursCompleted', 'balances', 'friends', 'friendRequestsSent', 'friendRequestsReceived'];
        
        // Ensure no fields outside the mutable list are being changed by the user for themselves.
        let onlyMutableFieldsTouched = incoming.keys().diff(existing.keys()).affectedKeys.hasOnly(mutableFields);

        // A safeguard to ensure core immutable properties are not changed.
        let coreDataUnchanged = incoming.uid == existing.uid &&
                                incoming.email == existing.email &&
                                incoming.createdAt.toMillis() == existing.createdAt.toMillis() &&
                                incoming.role == existing.role &&
                                incoming.isBlocked == existing.isBlocked;
        
        // Ensure a user cannot give themselves more money or spins.
        let balancesNotIncreased = !('balances' in incoming) || 
            incoming.balances.keys().every(
                tier => !(tier in existing.balances) || incoming.balances[tier] <= existing.balances[tier]
            );
        
        return onlyMutableFieldsTouched && coreDataUnchanged && balancesNotIncreased;
      }

      // User subcollections
      match /notifications/{notificationId} {
        allow read, write, delete: if isOwner(userId);
      }
    }

    // Transactions can be read by the user or finance staff. Created/Managed by server/admins only.
    match /transactions/{transactionId} {
      allow read: if isSignedIn() && (isOwner(resource.data.userId) || isFinanceStaffOrHigher());
      allow create, update, delete: if isFinanceStaffOrHigher();
    }
    
    // Users create their own fund/withdrawal requests. Finance staff processes them.
    match /addFundRequests/{requestId} {
       allow read: if isSignedIn() && (isOwner(resource.data.userId) || isFinanceStaffOrHigher());
       allow create: if isSignedIn() && isOwner(request.resource.data.userId);
       allow update: if isFinanceStaffOrHigher();
       allow delete: if isFinanceStaffOrHigher();
    }
    
    match /withdrawalRequests/{requestId} {
       allow read: if isSignedIn() && (isOwner(resource.data.userId) || isFinanceStaffOrHigher());
       allow create: if isSignedIn() && isOwner(request.resource.data.userId);
       allow update: if isFinanceStaffOrHigher();
       allow delete: if isFinanceStaffOrHigher();
    }
    
    // Users create support tickets, they and support staff can interact with them.
    match /supportTickets/{ticketId} {
      // User can only add a message. Support can change status too.
      // We check if the user is only appending to the messages array.
      function isAddingMessage() {
        return request.resource.data.messages.size() == resource.data.messages.size() + 1 &&
               request.resource.data.userId == resource.data.userId;
      }

      allow read: if isSignedIn() && (isOwner(resource.data.userId) || isSupportStaffOrHigher());
      allow create: if isSignedIn() && isOwner(request.resource.data.userId);
      allow update: if (isOwner(resource.data.userId) && isAddingMessage()) || isSupportStaffOrHigher();
      allow delete: if isSuperAdmin();
    }

    // Tournaments can be read by anyone. Admins manage them.
    match /tournaments/{tournamentId} {
      allow read: if true;
      allow create, update, delete: if isAdminOrHigher();

      // Users can join a tournament (create their participant doc). Admins manage scores.
      match /participants/{userId} {
        allow read: if true;
        allow create: if isOwner(userId);
        allow update, delete: if isAdminOrHigher();
      }
    }
    
    // System-wide collections
    match /appConfiguration/{docId} {
      allow read: if true;
      allow write: if isSuperAdmin();
    }

    match /systemStats/{docId} {
        allow read: if isAdminOrHigher();
        allow write: if false; // Should only be updated by secure server functions
    }

    match /activityLogs/{logId} {
        allow read, update, delete: if false;
        allow create: if isSignedIn();
    }
    
    match /fraudAlerts/{alertId} {
        allow read: if isAdminOrHigher();
        allow write: if false; // Triggered by server logic only
    }

    match /userRewards/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId); // Handled by server actions, but validated against owner
    }
  }
}
