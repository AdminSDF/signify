rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // This function checks if a NON-OWNER is making a valid change to friend lists.
    function isAllowedFriendsUpdate() {
      let requesterId = request.auth.uid;
      let incoming = request.resource.data;
      let existing = resource.data;

      // 1. Ensure no fields OTHER THAN the three friend-related lists are being changed.
      // This is the most crucial security check.
      let protectedFieldsUnchanged = 
          incoming.uid == existing.uid &&
          incoming.email == existing.email &&
          incoming.displayName == existing.displayName &&
          incoming.photoURL == existing.photoURL &&
          incoming.balances == existing.balances && 
          incoming.spinsAvailable == existing.spinsAvailable &&
          incoming.dailyPaidSpinsUsed == existing.dailyPaidSpinsUsed &&
          incoming.lastPaidSpinDate == existing.lastPaidSpinDate &&
          incoming.totalWinnings == existing.totalWinnings &&
          incoming.totalSpinsPlayed == existing.totalSpinsPlayed &&
          incoming.totalWins == existing.totalWins &&
          incoming.totalDeposited == existing.totalDeposited &&
          incoming.totalWithdrawn == existing.totalWithdrawn &&
          incoming.isAdmin == existing.isAdmin &&
          incoming.isBlocked == existing.isBlocked &&
          incoming.lastActive == existing.lastActive &&
          incoming.isOnline == existing.isOnline &&
          incoming.currentGame == existing.currentGame &&
          incoming.upiIdForWithdrawal == existing.upiIdForWithdrawal &&
          incoming.bankDetailsForWithdrawal == existing.bankDetailsForWithdrawal &&
          incoming.toursCompleted == existing.toursCompleted &&
          incoming.referralCode == existing.referralCode &&
          incoming.referredBy == existing.referredBy &&
          incoming.referrals == existing.referrals &&
          incoming.referralEarnings == existing.referralEarnings &&
          incoming.tags == existing.tags &&
          incoming.manualWinRateOverride == existing.manualWinRateOverride &&
          incoming.recentSpinHistory == existing.recentSpinHistory &&
          incoming.vipUntil == existing.vipUntil;

      if (!protectedFieldsUnchanged) {
        return false;
      }

      // 2. Check the changes in the friend-related arrays.
      let friendsDiff = incoming.friends.toSet().symmetricDifference(existing.friends.toSet());
      let sentDiff = incoming.friendRequestsSent.toSet().symmetricDifference(existing.friendRequestsSent.toSet());
      let receivedDiff = incoming.friendRequestsReceived.toSet().symmetricDifference(existing.friendRequestsReceived.toSet());
      
      // Combine all changes into one set.
      let allChanges = friendsDiff.union(sentDiff).union(receivedDiff);
      
      // The set of all changed UIDs must ONLY contain the requester's UID.
      // This prevents a user from adding/removing other people to the target's lists.
      return allChanges.hasOnly([requesterId]);
    }
    
    // --- User Profile Rules ---
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if isOwner(userId);
      
      // Allow update if you are the owner OR if you are a non-owner performing a valid friend action.
      allow update: if (isOwner(userId)) || 
                     (!isOwner(userId) && isAllowedFriendsUpdate());
      
      // --- Subcollection Rules ---
      match /notifications/{notificationId} {
        // A user can create a notification for another user (e.g. friend request).
        allow create: if !isOwner(userId);
        // Only the owner can read or delete their notifications.
        allow read, delete: if isOwner(userId);
        allow update: if false;
      }
    }
    
    // --- Rules for other collections ---
    match /appConfiguration/{docId} { 
      allow read: if true; 
      allow write: if false; 
    }

    match /transactions/{transactionId} { 
      allow create: if request.resource.data.userId == request.auth.uid;
      allow read: if resource.data.userId == request.auth.uid;
      allow update, delete: if false; 
    }
    
    match /withdrawalRequests/{reqId} { 
      allow create: if request.resource.data.userId == request.auth.uid;
      allow read: if resource.data.userId == request.auth.uid;
      allow update, delete: if false; 
    }

    match /addFundRequests/{reqId} { 
      allow create: if request.resource.data.userId == request.auth.uid;
      allow read: if resource.data.userId == request.auth.uid;
      allow update, delete: if false; 
    }

    match /supportTickets/{ticketId} {
      allow create: if request.resource.data.userId == request.auth.uid;
      allow read: if resource.data.userId == request.auth.uid;
      allow update, delete: if false; 
    }
    
    match /tournaments/{tId} { 
      allow read: if true; 
      allow update: if request.auth.uid in request.resource.data.participants;
      allow create, delete: if false;
    }

    match /userTournaments/{utId} { 
      allow read: if true; 
      allow create: if request.resource.data.userId == request.auth.uid;
      allow update: if resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /activityLogs/{logId} { 
      allow create: if request.resource.data.userId == request.auth.uid;
      allow read, update, delete: if false;
    }

    match /userRewards/{rewId} { 
      allow read, write: if isOwner(rewId); 
    }
    
    match /fraudAlerts/{alertId} {
        allow read, write: if false;
    }
    
    match /systemStats/{statsId} {
        allow read, write: if false;
    }
  }
}